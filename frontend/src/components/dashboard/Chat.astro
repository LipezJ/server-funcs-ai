---
import Loader from "../icons/Loader.astro";
import Button from "../ui/Button.astro";
---

<script>
  import { Mode, codeAtom } from '@/lib/code.store'
  import { streamText, type CoreMessage } from 'ai'
  import { ollama } from 'ollama-ai-provider'
  import showdown from 'showdown'

  const AI_SYSTEM_PROMPT = `
    You specialize in writing JavaScript functions for a serverless AI-driven service. Follow these guidelines:

    1. Functions must always be named "handler".
    2. Functions must be asynchronous.
    3. Do not include comments or explanations unless requested,.never!
    4. Respond only to function-related requests.
    5. Functions can receive only one parameter (use objects for multiple parameters).
    6. Provide only updated code for corrections or modifications.
    7. Keep explanations short and direct.
    8. Answer all function-related questions.
    9. In a pure vanilla V8 environment, you do not have access to APIs like fetch or XMLHttpRequest, as 
    these are specific to browser or server environments with additional support.

    Example format:

    "
      async function handler(params) {
        return params.a + params.b;
      }
    "
  `

  const converter = new showdown.Converter()

  class Chat extends HTMLElement {

    disabled = false
    messages = [] as unknown as CoreMessage[]

    constructor() {
      super()
    }

    connectedCallback() {
      const $form = this.querySelector('form#message-form') as HTMLFormElement

      $form?.addEventListener('submit', (e) => {
        e.preventDefault()
        if (!e.target || this.disabled) return

        const form = new FormData(e.target as HTMLFormElement)
        const message = form.get('message') as string

        this.sendMessage(message)
        $form.reset()
      })
    }

    setDisable(status: boolean) {
      const $button = this.querySelector('form button') as HTMLButtonElement
      
      if (!$button) return

      this.disabled = status
      $button.disabled = this.disabled
    }

    sendMessage(message: string) {
      const messageContent: CoreMessage = { role: 'user', content: message }

      this.messages.push(messageContent)

      const $messageBox = this.querySelector('#message-box')

      if (!$messageBox) return

      const $message = document.createElement('div')
      $message.className = `message-${messageContent.role}`
      $message.textContent = messageContent.content as string

      $messageBox.appendChild($message)

      this.setDisable(true)
      this.aiResponse()
        .finally(() => {
          console.log("fin de ia")
          this.setDisable(false)
        })
    }

    async aiResponse() {
      const $messageBox = this.querySelector('#message-box')

      const $loaderTemplate = this.querySelector('template#loader') as HTMLTemplateElement
      const $messageLoader = $loaderTemplate.content.cloneNode(true) as HTMLElement
      $messageBox?.appendChild($messageLoader)

      const result = await streamText({
        model: ollama('phi3'),
        system: AI_SYSTEM_PROMPT,
        messages: this.messages
      })

      const $message = document.createElement('div')
      $message.className = `message-assistant`

      $messageBox?.querySelector("#message-loader")?.remove()
      $messageBox?.appendChild($message)

      for await (const part of result.textStream) {
        $message.textContent += part
      }

      const content = $message.textContent ?? ""
      const html = converter.makeHtml(content)

      const $codeTemplate = this.querySelector('template#code') as HTMLTemplateElement

      $message.setHTMLUnsafe(html)

      $message.querySelectorAll('pre').forEach((block) => {
        const $code = block.querySelector('code');

        // @ts-ignore
        hljs.highlightBlock($code);

        const $codeBlock = $codeTemplate.content.cloneNode(true) as HTMLElement;
        const $codeContainer = $codeBlock.querySelector('code-block');

        $codeContainer?.insertBefore(block.cloneNode(true), $codeContainer?.firstElementChild);
        block.replaceWith($codeBlock);
      });

      this.messages.push({ role: 'assistant', content })
    }
  }

  class CodeBlock extends HTMLElement {
    constructor() {
      super()
    }

    connectedCallback() {
      const $button = this.querySelector('button') as HTMLButtonElement
      console.log(this)

      $button?.addEventListener('click', () => {
        const $code = this.querySelector('pre code') as HTMLElement
        const code = $code.textContent

        codeAtom.set(code ?? "")
        Mode.toggle()
      })
    }
  }

  customElements.define('chat-box', Chat)
  customElements.define('code-block', CodeBlock)
</script>

<chat-box class="flex flex-col items-center h-full gap-1 text-black overflow-hidden">
  <div id="message-box" class="overflow-y-auto flex-1 flex flex-col justify-end gap-2.5 pr-0.5 w-full"></div>
  <form id="message-form" class="flex gap-1 md:w-5/6">
    <input 
      name="message" 
      type="text" 
      class="items-center gap-1 rounded-sm border border-paragraph p-2 mr-1 h-fit w-full"
    />
    <Button style="pri" class="px-2 disabled:bg-pri/60 disabled:border-pri/60">
      Send
    </Button>
  </form>

  <template id="loader">
    <div id="message-loader" class="message-assistant">
      <Loader />
    </div>
  </template>

  <template id="code">
    <code-block class="h-fit flex flex-col">
      <div class="flex justify-end">
        <Button style="pri" class="px-1.5">Use</Button>
      </div>
    </code-block>
  </template>
</chat-box>

<style is:global>
  .message-user, .message-assistant {
    background-color: #f3f4f6;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    width: max-content;
    max-width: 80%;
    word-wrap: break-word;
  }

  .message-user {
    align-self: flex-end;
    border-end-end-radius: 0rem;
  }

  .message-assistant {
    align-self: flex-start;
    border-end-start-radius: 0rem;
  }

  pre {
    background-color: #0f0e17;
    padding: 0.5rem 1rem;
    border-top-left-radius: 0.5rem;
    border-top-right-radius: 0.5rem;
    margin: 0.5rem 0 0.1rem 0;
    overflow-x: auto
  }
</style>